/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AttachmentManagementPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings/settings.ts
var import_obsidian = require("obsidian");

// src/lib/constant.ts
var RENAME_EVENT_TYPE_FOLDER = "RENAME_EVENT_TYPE_FOLDER";
var RENAME_EVENT_TYPE_FILE = "RENAME_EVENT_TYPE_FILE";
var SETTINGS_VARIABLES_DATES = "${date}";
var SETTINGS_VARIABLES_NOTEPATH = "${notepath}";
var SETTINGS_VARIABLES_NOTENAME = "${notename}";
var SETTINGS_VARIABLES_NOTEPARENT = "${parent}";
var SETTINGS_VARIABLES_ORIGINALNAME = "${originalname}";
var SETTINGS_ROOT_OBSFOLDER = "obsFolder";
var SETTINGS_ROOT_INFOLDER = "inFolderBelow";
var SETTINGS_ROOT_NEXTTONOTE = "nextToNote";

// src/log.ts
var DEBUG = false;
if (DEBUG)
  console.log("DEBUG is enabled");
function debugLog(...args) {
  if (DEBUG) {
    console.log(new Date().toISOString().slice(11, 23), ...args);
  }
}

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  attachPath: {
    attachmentRoot: "",
    saveAttE: `${SETTINGS_ROOT_OBSFOLDER}`,
    attachmentPath: `${SETTINGS_VARIABLES_NOTEPATH}/${SETTINGS_VARIABLES_NOTENAME}`,
    attachFormat: `IMG-${SETTINGS_VARIABLES_DATES}`,
    type: "GLOBAL" /* GLOBAL */
  },
  dateFormat: "YYYYMMDDHHmmssSSS",
  handleAll: false,
  excludeExtensionPattern: "",
  autoRenameAttachment: true,
  excludedPaths: "",
  excludePathsArray: [],
  excludeSubpaths: false,
  overridePath: {}
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  displaySw(cont) {
    cont.findAll(".setting-item").forEach((el) => {
      var _a, _b;
      if ((_a = el.getAttr("class")) == null ? void 0 : _a.includes("root_folder_set")) {
        if (this.plugin.settings.attachPath.saveAttE === "obsFolder") {
          el.hide();
        } else {
          el.show();
        }
      }
      if ((_b = el.getAttr("class")) == null ? void 0 : _b.includes("exclude_extension_pattern")) {
        if (!this.plugin.settings.handleAll) {
          el.hide();
        } else {
          el.show();
        }
      }
    });
  }
  splitPath(path2) {
    const splitted = path2.split(";");
    const rets = [];
    for (const s of splitted) {
      rets.push(s.trim());
    }
    return { splittedPaths: rets };
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Root path to save new attachments").setDesc("Select root path for all new attachments").addDropdown(
      (text) => text.addOption(`${SETTINGS_ROOT_OBSFOLDER}`, "Copy Obsidian settings").addOption(`${SETTINGS_ROOT_INFOLDER}`, "In the folder specified below").addOption(`${SETTINGS_ROOT_NEXTTONOTE}`, "Next to note in folder specified below").setValue(this.plugin.settings.attachPath.saveAttE).onChange(async (value) => {
        this.plugin.settings.attachPath.saveAttE = value;
        this.displaySw(containerEl);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Root folder").setDesc("Root folder of new attachment").setClass("root_folder_set").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachmentRoot).setValue(this.plugin.settings.attachPath.attachmentRoot).onChange(async (value) => {
        debugLog("setting - attachment root:" + value);
        this.plugin.settings.attachPath.attachmentRoot = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Attachment path").setDesc(
      `Path of new attachment in root folder, available variables ${SETTINGS_VARIABLES_NOTEPATH}, ${SETTINGS_VARIABLES_NOTENAME}, ${SETTINGS_VARIABLES_NOTEPARENT}`
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachmentPath).setValue(this.plugin.settings.attachPath.attachmentPath).onChange(async (value) => {
        debugLog("setting - attachment path:" + value);
        this.plugin.settings.attachPath.attachmentPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Attachment format").setDesc(
      `Define how to name the attachment file, available variables ${SETTINGS_VARIABLES_DATES}, ${SETTINGS_VARIABLES_NOTENAME} and ${SETTINGS_VARIABLES_ORIGINALNAME}.`
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachFormat).setValue(this.plugin.settings.attachPath.attachFormat).onChange(async (value) => {
        debugLog("setting - attachment format:" + value);
        this.plugin.settings.attachPath.attachFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc(
      createFragment((frag) => {
        frag.appendText("Moment date format to use ");
        frag.createEl("a", {
          href: "https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format",
          text: "Moment format options"
        });
      })
    ).addMomentFormat((component) => {
      component.setPlaceholder(DEFAULT_SETTINGS.dateFormat).setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        debugLog("setting - date format:" + value);
        this.plugin.settings.dateFormat = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Handle all attachments").setDesc(
      "By default, only auto-rename the image file, if enable this option, all created file (except 'md' or 'canvas') will be renamed automatically"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.handleAll).onChange(async (value) => {
        debugLog("setting - handle all attachment:" + value);
        this.plugin.settings.handleAll = value;
        this.displaySw(containerEl);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Exclude extension pattern").setDesc(
      `This option is only useful when "Handle all attachments" is enabled.	Write a Regex pattern to exclude certain extensions from being handled.`
    ).setClass("exclude_extension_pattern").setClass("attach_management_sub_setting").addText(
      (text) => text.setPlaceholder("pdf|docx?|xlsx?|pptx?|zip|rar").setValue(this.plugin.settings.excludeExtensionPattern).onChange(async (value) => {
        this.plugin.settings.excludeExtensionPattern = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Automatically rename attachment").setDesc(
      "Automatically rename the attachment folder/filename when you rename the folder/filename where the corresponding md/canvas file be placed."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoRenameAttachment).onChange(async (value) => {
        debugLog("setting - automatically rename attachment folder:" + value);
        this.plugin.settings.autoRenameAttachment = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Excluded paths").setDesc(
      `Provide the full path of the folder names (case sensitive and without leading slash '/') divided by semicolon (;) to be excluded from renaming.`
    ).addTextArea((component) => {
      component.setValue(this.plugin.settings.excludedPaths).onChange(async (value) => {
        this.plugin.settings.excludedPaths = value;
        const { splittedPaths } = this.splitPath(value);
        this.plugin.settings.excludePathsArray = splittedPaths;
        debugLog("setting - excluded paths:" + value, splittedPaths);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Exclude subpaths").setDesc("Turn on this option if you want to also exclude all subfolders of the folder paths provided above.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeSubpaths).onChange(async (value) => {
        debugLog("setting - excluded subpaths:" + value);
        this.plugin.settings.excludeSubpaths = value;
        await this.plugin.saveSettings();
      })
    );
    this.displaySw(containerEl);
  }
};

// src/model/override.ts
var import_obsidian2 = require("obsidian");
var OverrideModal = class extends import_obsidian2.Modal {
  constructor(plugin, file, setting) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.setting = setting;
  }
  displaySw(cont) {
    cont.findAll(".setting-item").forEach((el) => {
      var _a;
      if ((_a = el.getAttr("class")) == null ? void 0 : _a.includes("override_root_folder_set")) {
        if (this.setting.saveAttE === "obsFolder") {
          el.hide();
        } else {
          el.show();
        }
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", {
      text: "Overriding Settings"
    });
    new import_obsidian2.Setting(contentEl).setName("Root path to save new attachments").setDesc("Select root path for all new attachments").addDropdown(
      (text) => text.addOption(`${SETTINGS_ROOT_OBSFOLDER}`, "Copy Obsidian settings").addOption(`${SETTINGS_ROOT_INFOLDER}`, "In the folder specified below").addOption(`${SETTINGS_ROOT_NEXTTONOTE}`, "Next to note in folder specified below").setValue(this.setting.saveAttE).onChange(async (value) => {
        this.setting.saveAttE = value;
        this.displaySw(contentEl);
      })
    );
    new import_obsidian2.Setting(contentEl).setName("Root folder").setClass("override_root_folder_set").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachmentRoot).setValue(this.setting.attachmentRoot).onChange(async (value) => {
        debugLog("override - attachment root:" + value);
        this.setting.attachmentRoot = value;
      })
    );
    new import_obsidian2.Setting(contentEl).setName("Attachment path").setDesc(
      `Path of new attachment in root folder, available variables ${SETTINGS_VARIABLES_NOTEPATH}, ${SETTINGS_VARIABLES_NOTENAME} and ${SETTINGS_VARIABLES_NOTEPARENT}`
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachmentPath).setValue(this.setting.attachmentPath).onChange(async (value) => {
        debugLog("override - attachment path:" + value);
        this.setting.attachmentPath = value;
      })
    );
    new import_obsidian2.Setting(contentEl).setName("Attachment format").setDesc(
      `Define how to name the attachment file, available variables ${SETTINGS_VARIABLES_DATES} and ${SETTINGS_VARIABLES_NOTENAME}`
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.attachPath.attachFormat).setValue(this.setting.attachFormat).onChange(async (value) => {
        debugLog("override - attachment format:" + value);
        this.setting.attachFormat = value;
      })
    );
    new import_obsidian2.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Reset").onClick(async () => {
        this.setting = this.plugin.settings.attachPath;
        delete this.plugin.settings.overridePath[this.file.path];
        await this.plugin.saveSettings();
        await this.plugin.loadSettings();
        new import_obsidian2.Notice(`Reset attachment setting of ${this.file.path}`);
        this.close();
      });
    }).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(async () => {
        if (this.file instanceof import_obsidian2.TFile) {
          this.setting.type = "FILE" /* FILE */;
        } else if (this.file instanceof import_obsidian2.TFolder) {
          this.setting.type = "FOLDER" /* FOLDER */;
        }
        this.plugin.settings.overridePath[this.file.path] = this.setting;
        await this.plugin.saveSettings();
        debugLog("override - overriding settings:", this.file.path, this.setting);
        this.close();
      })
    );
    this.displaySw(contentEl);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/lib/path.ts
var path = {
  // Credit: [@creationix/path.js](https://gist.github.com/creationix/7435851)
  join(...partSegments) {
    let parts = [];
    for (let i = 0, l = partSegments.length; i < l; i++) {
      parts = parts.concat(partSegments[i].split("/"));
    }
    const newParts = [];
    for (let i = 0, l = parts.length; i < l; i++) {
      const part = parts[i];
      if (!part || part === ".")
        continue;
      if (part === "..")
        newParts.pop();
      else
        newParts.push(part);
    }
    if (parts[0] === "")
      newParts.unshift("");
    return newParts.join("/");
  },
  // A simple function to get the dirname of a path
  // Trailing slashes are ignored. Leading slash is preserved.
  dirname(filepath) {
    return this.join(filepath, "..");
  },
  // returns the last part of a path, e.g. 'foo.jpg'
  basename(filepath, extension = "") {
    const sp = filepath.split("/");
    const filename = sp[sp.length - 1];
    if (extension !== "") {
      return filename.slice(0, filename.length - extension.length - 1);
    }
    return sp[sp.length - 1];
  },
  // return extension without dot, e.g. 'jpg'
  extname(filepath) {
    const positions = [...filepath.matchAll(new RegExp("\\.", "gi"))].map((a) => a.index);
    const idx = positions[positions.length - 1];
    if (idx === void 0) {
      return "";
    }
    return filepath.slice(idx + 1);
  }
};

// src/commons.ts
var import_obsidian3 = require("obsidian");
function getActiveFile(app2) {
  const view = getActiveView(app2);
  return view == null ? void 0 : view.file;
}
function getActiveView(app2) {
  return app2.workspace.getActiveViewOfType(import_obsidian3.TextFileView);
}
function getRootPath(notePath, setting) {
  let root;
  const obsmediadir = app.vault.getConfig("attachmentFolderPath");
  switch (setting.saveAttE) {
    case `${SETTINGS_ROOT_INFOLDER}`:
      root = path.join(setting.attachmentRoot);
      break;
    case `${SETTINGS_ROOT_NEXTTONOTE}`:
      root = path.join(notePath, setting.attachmentRoot.replace("./", ""));
      break;
    default:
      if (obsmediadir === "/") {
        root = obsmediadir;
      } else if (obsmediadir === "./") {
        root = path.join(notePath);
      } else if (obsmediadir.match(/\.\/.+/g) !== null) {
        root = path.join(notePath, obsmediadir.replace("./", ""));
      } else {
        root = obsmediadir;
      }
  }
  return root === "/" ? root : (0, import_obsidian3.normalizePath)(root);
}

// src/override.ts
var import_obsidian5 = require("obsidian");

// src/utils.ts
var import_obsidian4 = require("obsidian");
var PASTED_IMAGE_PREFIX = "Pasted image ";
var ImageExtensionRegex = /^(jpe?g|png|gif|svg|bmp|eps|webp)$/i;
function isMarkdownFile(extension) {
  return extension === "md";
}
function isCanvasFile(extension) {
  return extension === "canvas";
}
function isPastedImage(file) {
  if (file instanceof import_obsidian4.TFile) {
    if (file.name.startsWith(PASTED_IMAGE_PREFIX)) {
      return true;
    }
  }
  return false;
}
function isImage(extension) {
  const match = extension.match(ImageExtensionRegex);
  if (match !== null) {
    return true;
  }
  return false;
}
function stripPaths(src, dst) {
  if (src === dst) {
    return { stripedSrc: src, stripedDst: dst };
  }
  const srcParts = src.split("/");
  const dstParts = dst.split("/");
  if (srcParts.length !== dstParts.length) {
    return { stripedSrc: src, stripedDst: dst };
  }
  for (let i = 0; i < srcParts.length; i++) {
    const srcPart = srcParts[i];
    const dstPart = dstParts[i];
    if (srcPart !== dstPart) {
      return {
        stripedSrc: srcParts.slice(0, i + 1).join("/"),
        stripedDst: dstParts.slice(0, i + 1).join("/")
      };
    }
  }
  return { stripedSrc: "", stripedDst: "" };
}
function testExcludeExtension(extension, pattern) {
  if (!pattern || pattern === "")
    return false;
  return new RegExp(pattern).test(extension);
}
function isAttachment(settings, filePath) {
  let file = null;
  if (filePath instanceof import_obsidian4.TAbstractFile) {
    file = filePath;
  } else {
    file = this.app.vault.getAbstractFileByPath(filePath);
  }
  if (file === null || !(file instanceof import_obsidian4.TFile)) {
    return false;
  }
  if (isMarkdownFile(file.extension) || isCanvasFile(file.extension)) {
    return false;
  }
  return isImage(file.extension) || settings.handleAll && !testExcludeExtension(file.extension, settings.excludeExtensionPattern);
}
function attachRenameType(setting) {
  let ret = "BOTH" /* BOTH */;
  if (setting.attachFormat.includes(SETTINGS_VARIABLES_NOTENAME)) {
    if (setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTENAME) || setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTEPATH) || setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTEPARENT)) {
      ret = "BOTH" /* BOTH */;
    } else {
      ret = "FILE" /* FILE */;
    }
  } else if (setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTENAME) || setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTEPATH) || setting.attachmentPath.includes(SETTINGS_VARIABLES_NOTEPARENT)) {
    ret = "FOLDER" /* FOLDER */;
  }
  return ret;
}

// src/override.ts
function getOverrideSetting(settings, file, oldPath = "") {
  if (Object.keys(settings.overridePath).length === 0) {
    return { settingPath: "", setting: settings.attachPath };
  }
  const candidates = {};
  let fileType;
  let filePath;
  fileType = file instanceof import_obsidian5.TFile;
  fileType = !(file instanceof import_obsidian5.TFolder);
  if (oldPath === "") {
    filePath = file.path;
  } else {
    filePath = oldPath;
  }
  for (const overridePath of Object.keys(settings.overridePath)) {
    const overrideSetting = settings.overridePath[overridePath];
    if (fileType) {
      if (overridePath === filePath && overrideSetting.type === "FILE" /* FILE */) {
        return { settingPath: overridePath, setting: overrideSetting };
      } else if (filePath.startsWith(overridePath) && filePath.charAt(overridePath.length) === "/" && overrideSetting.type === "FOLDER" /* FOLDER */) {
        candidates[overridePath] = overrideSetting;
      }
    } else {
      if (overridePath === filePath && overrideSetting.type === "FOLDER" /* FOLDER */) {
        return { settingPath: overridePath, setting: overrideSetting };
      } else if (filePath.startsWith(overridePath) && filePath.charAt(overridePath.length) === "/" && overrideSetting.type === "FOLDER" /* FOLDER */) {
        candidates[overridePath] = overrideSetting;
      }
    }
  }
  if (Object.keys(candidates).length === 0) {
    return { settingPath: "", setting: settings.attachPath };
  }
  const sortedK = Object.keys(candidates).sort(
    (a, b) => a.split("/").length > b.split("/").length ? -1 : a.split("/").length < b.split("/").length ? 1 : 0
  );
  debugLog("getOverrideSetting - sortedK:", sortedK);
  for (const k of sortedK) {
    if (filePath.startsWith(k)) {
      return { settingPath: k, setting: candidates[k] };
    }
  }
  return { settingPath: "", setting: settings.attachPath };
}
function getRenameOverrideSetting(settings, file, oldPath) {
  if (Object.keys(settings.overridePath).length === 0) {
    return { settingPath: "", setting: settings.attachPath };
  }
  const { settingPath: np, setting: ns } = getOverrideSetting(settings, file);
  const { settingPath: op, setting: os } = getOverrideSetting(settings, file, oldPath);
  if (ns.type === "GLOBAL" /* GLOBAL */) {
    return { settingPath: op, setting: os };
  }
  if (os.type === "GLOBAL" /* GLOBAL */) {
    return { settingPath: np, setting: ns };
  }
  if (ns.type === "FILE" /* FILE */ && os.type === "FILE" /* FILE */) {
    debugLog("getRenameOverrideSetting - both file type setting", np, op);
    return { settingPath: "", setting: settings.attachPath };
  }
  if (ns.type === "FILE" /* FILE */ && os.type === "FOLDER" /* FOLDER */) {
    return { settingPath: np, setting: ns };
  } else if (ns.type === "FOLDER" /* FOLDER */ && os.type === "FILE" /* FILE */) {
    return { settingPath: op, setting: os };
  }
  if (ns.type === "FOLDER" /* FOLDER */ && os.type === "FOLDER" /* FOLDER */) {
    const l = np.split("/").length;
    const r = op.split("/").length;
    if (l > r) {
      return { settingPath: np, setting: ns };
    } else if (l < r) {
      return { settingPath: op, setting: os };
    } else if (l === r) {
      return { settingPath: "", setting: settings.attachPath };
    }
  }
  return { settingPath: "", setting: settings.attachPath };
}
function updateOverrideSetting(settings, file, oldPath) {
  const keys = Object.keys(settings.overridePath);
  if (keys.length === 0 || file.path === oldPath) {
    return;
  }
  const { settingPath, setting } = getOverrideSetting(settings, file, oldPath);
  const copySetting = Object.assign({}, setting);
  if (file.path === settingPath) {
    return;
  }
  if (oldPath === settingPath) {
    settings.overridePath[file.path] = copySetting;
    delete settings.overridePath[settingPath];
    return;
  } else {
    const { stripedSrc, stripedDst } = stripPaths(oldPath, file.path);
    if (stripedSrc === settingPath) {
      settings.overridePath[stripedDst] = copySetting;
      delete settings.overridePath[settingPath];
      return;
    }
  }
}
function deleteOverrideSetting(settings, file) {
  const keys = Object.keys(settings.overridePath);
  for (const key of keys) {
    if (file.path === key) {
      delete settings.overridePath[key];
      return true;
    }
  }
  return false;
}

// src/arrange.ts
var import_obsidian7 = require("obsidian");

// src/lib/linkDetector.ts
var getAllLinkMatchesInFile = async (mdFile, app2, fileText) => {
  const linkMatches = [];
  if (fileText === void 0) {
    fileText = await app2.vault.read(mdFile);
  }
  const wikiRegex = /\[\[.*?\]\]/g;
  const wikiMatches = fileText.match(wikiRegex);
  if (wikiMatches) {
    const fileRegex = /(?<=\[\[).*?(?=(\]|\|))/;
    for (const wikiMatch of wikiMatches) {
      if (matchIsWikiTransclusion(wikiMatch)) {
        const fileName = getTransclusionFileName(wikiMatch);
        const file = app2.metadataCache.getFirstLinkpathDest(fileName, mdFile.path);
        if (fileName !== "") {
          const linkMatch = {
            type: "wikiTransclusion",
            match: wikiMatch,
            linkText: file ? file.path : fileName,
            sourceFilePath: mdFile.path
          };
          linkMatches.push(linkMatch);
          continue;
        }
      }
      const fileMatch = wikiMatch.match(fileRegex);
      if (fileMatch) {
        if (fileMatch[0].startsWith("http"))
          continue;
        const file = app2.metadataCache.getFirstLinkpathDest(fileMatch[0], mdFile.path);
        const linkMatch = {
          type: "wiki",
          match: wikiMatch,
          linkText: file ? file.path : fileMatch[0],
          sourceFilePath: mdFile.path
        };
        linkMatches.push(linkMatch);
      }
    }
  }
  const markdownRegex = /\[(^$|.*?)\]\((.*?)\)/g;
  const markdownMatches = fileText.match(markdownRegex);
  if (markdownMatches) {
    const fileRegex = /(?<=\().*(?=\))/;
    for (const markdownMatch of markdownMatches) {
      if (matchIsMdTransclusion(markdownMatch)) {
        const fileName = getTransclusionFileName(markdownMatch);
        const file = app2.metadataCache.getFirstLinkpathDest(fileName, mdFile.path);
        if (fileName !== "") {
          const linkMatch = {
            type: "mdTransclusion",
            match: markdownMatch,
            linkText: file ? file.path : fileName,
            sourceFilePath: mdFile.path
          };
          linkMatches.push(linkMatch);
          continue;
        }
      }
      const fileMatch = markdownMatch.match(fileRegex);
      if (fileMatch) {
        if (fileMatch[0].startsWith("http"))
          continue;
        const file = app2.metadataCache.getFirstLinkpathDest(fileMatch[0], mdFile.path);
        const linkMatch = {
          type: "markdown",
          match: markdownMatch,
          linkText: file ? file.path : fileMatch[0],
          sourceFilePath: mdFile.path
        };
        linkMatches.push(linkMatch);
      }
    }
  }
  return linkMatches;
};
var wikiTransclusionRegex = /\[\[(.*?)#.*?\]\]/;
var wikiTransclusionFileNameRegex = /(?<=\[\[)(.*)(?=#)/;
var mdTransclusionRegex = /\[.*?]\((.*?)#.*?\)/;
var mdTransclusionFileNameRegex = /(?<=\]\()(.*)(?=#)/;
var matchIsWikiTransclusion = (match) => {
  return wikiTransclusionRegex.test(match);
};
var matchIsMdTransclusion = (match) => {
  return mdTransclusionRegex.test(match);
};
var getTransclusionFileName = (match) => {
  const isWiki = wikiTransclusionRegex.test(match);
  const isMd = mdTransclusionRegex.test(match);
  if (isWiki || isMd) {
    const fileNameMatch = match.match(isWiki ? wikiTransclusionFileNameRegex : mdTransclusionFileNameRegex);
    if (fileNameMatch)
      return fileNameMatch[0];
  }
  return "";
};

// src/lib/deduplicate.ts
function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
async function deduplicateNewName(newName, file) {
  const dir = file.path;
  const listed = await this.app.vault.adapter.list(dir);
  debugLog("sibling files", listed);
  const newNameExt = path.extname(newName), newNameStem = newName.slice(0, newName.length - newNameExt.length - 1), newNameStemEscaped = escapeRegExp(newNameStem), delimiter = "-", delimiterEscaped = escapeRegExp(delimiter);
  const dupNameRegex = new RegExp(`^(?<name>${newNameStemEscaped})${delimiterEscaped}(?<number>\\d+)\\.${newNameExt}$`);
  debugLog("dupNameRegex", dupNameRegex);
  const dupNameNumbers = [];
  let isNewNameExist = false;
  for (let sibling of listed.files) {
    sibling = path.basename(sibling);
    if (sibling == newName) {
      isNewNameExist = true;
      continue;
    }
    const m = dupNameRegex.exec(sibling);
    if (!m || m.groups === void 0)
      continue;
    dupNameNumbers.push(parseInt(m.groups.number));
  }
  if (isNewNameExist) {
    const newNumber = dupNameNumbers.length > 0 ? Math.max(...dupNameNumbers) + 1 : 1;
    newName = `${newNameStem}${delimiter}${newNumber}.${newNameExt}`;
  }
  return {
    name: newName,
    basename: newName.slice(0, newName.length - newNameExt.length - 1),
    extension: newNameExt
  };
}

// src/metadata.ts
var import_obsidian6 = require("obsidian");
var Metadata = class {
  constructor(path2, name, basename, extension, parentPath, parentName) {
    /** parent path of file */
    this.parentPath = "";
    /** parent path basename of file */
    this.parentName = "";
    this.path = path2;
    this.name = name;
    this.basename = basename;
    this.extension = extension;
    this.parentPath = parentPath;
    this.parentName = parentName;
  }
  /**
   * Returns a formatted attachment file name according to the provided settings.
   *
   * @param {AttachmentPathSettings} setting - attachment path settings object
   * @param {string} dateFormat - format string for date and time
   * @param {string} originalName - name of the original attachment
   * @param {string} [linkName] - optional name for the attachment link
   * @return {string} the formatted attachment file name
   */
  getAttachFileName(setting, dateFormat, originalName, linkName) {
    const dateTime = window.moment().format(dateFormat);
    if (setting.attachFormat.includes(SETTINGS_VARIABLES_ORIGINALNAME)) {
      if (originalName === "" && linkName != void 0) {
        return linkName;
      } else {
        return setting.attachFormat.replace(`${SETTINGS_VARIABLES_DATES}`, dateTime).replace(`${SETTINGS_VARIABLES_NOTENAME}`, this.basename).replace(`${SETTINGS_VARIABLES_ORIGINALNAME}`, originalName);
      }
    }
    return setting.attachFormat.replace(`${SETTINGS_VARIABLES_DATES}`, dateTime).replace(`${SETTINGS_VARIABLES_NOTENAME}`, this.basename);
  }
  /**
   * Returns the attachment path based on the given AttachmentPathSettings object.
   *
   * @param {AttachmentPathSettings} setting - An object containing the attachment path settings.
   * @return {string} The normalized attachment path.
   */
  getAttachmentPath(setting) {
    const root = getRootPath(this.parentPath, setting);
    const attachPath = path.join(
      root,
      setting.attachmentPath.replace(`${SETTINGS_VARIABLES_NOTEPATH}`, this.parentPath).replace(`${SETTINGS_VARIABLES_NOTENAME}`, this.basename).replace(`${SETTINGS_VARIABLES_NOTEPARENT}`, this.parentName)
    );
    return (0, import_obsidian6.normalizePath)(attachPath);
  }
};
function getMetadata(file) {
  const parentPath = path.dirname(file);
  const parentName = path.basename(parentPath);
  const name = path.basename(file);
  const extension = path.extname(file);
  const basename = path.basename(file, extension);
  return new Metadata(file, name, basename, extension, parentPath, parentName);
}

// src/exclude.ts
function isExcluded(path2, settings) {
  debugLog("excludePathsArray: ", settings.excludePathsArray);
  for (const excludedPath of settings.excludePathsArray) {
    if (excludedPath.length === 0) {
      continue;
    }
    if (settings.excludeSubpaths && path2.startsWith(excludedPath)) {
      debugLog("isExcluded: ", path2);
      return true;
    } else {
      if (path2 === excludedPath) {
        return true;
      }
    }
  }
  return false;
}

// src/arrange.ts
var bannerRegex = /!\[\[(.*?)\]\]/i;
var ArrangeHandler = class {
  constructor(settings, app2) {
    this.settings = settings;
    this.app = app2;
  }
  /**
   * Rearranges attachments that are linked by markdown or canvas.
   * Only rearranges attachments if autoRenameAttachment is enabled in settings.
   *
   * @param {"active" | "links"} type - specifies whether to rearrange the active file attachments or
   * only those that are linked by markdown or canvas.
   * @return {void} nothing is returned
   */
  async rearrangeAttachment(type) {
    if (!this.settings.autoRenameAttachment) {
      debugLog("rearrangeAttachment - autoRenameAttachment not enable");
      return;
    }
    const attachments = await this.getAttachmentsInVault(this.settings, type);
    debugLog("rearrangeAttachment - attachments:", Object.keys(attachments).length, Object.entries(attachments));
    for (const obNote of Object.keys(attachments)) {
      const innerFile = this.app.vault.getAbstractFileByPath(obNote);
      if (!(innerFile instanceof import_obsidian7.TFile) || isAttachment(this.settings, innerFile)) {
        debugLog(`rearrangeAttachment - ${obNote} not exists or is attachment, skipped`);
        continue;
      }
      const { setting } = getOverrideSetting(this.settings, innerFile);
      const type2 = attachRenameType(setting);
      if (type2 === "NULL" /* NULL */) {
        debugLog("rearrangeAttachment - no variable use, skipped");
        return;
      }
      const metadata = getMetadata(obNote);
      const attachPath = metadata.getAttachmentPath(setting);
      for (let link of attachments[obNote]) {
        try {
          link = decodeURI(link);
        } catch (err) {
          console.log(`Invalid link: ${link}, err: ${err}`);
          continue;
        }
        debugLog(`rearrangeAttachment - article: ${obNote} links: ${link}`);
        const linkFile = this.app.vault.getAbstractFileByPath(link);
        if (linkFile === null) {
          debugLog(`${link} not exists, skipped`);
          continue;
        }
        const attachName = metadata.getAttachFileName(
          setting,
          this.settings.dateFormat,
          "",
          path.basename(link, path.extname(link))
        );
        if (!this.needToRename(setting, attachPath, attachName, metadata.basename, link)) {
          debugLog("rearrangeAttachment - no need to rename:", link);
          continue;
        }
        if (!await this.app.vault.adapter.exists(attachPath)) {
          await this.app.vault.adapter.mkdir(attachPath);
        }
        const attachPathFile = this.app.vault.getAbstractFileByPath(attachPath);
        const { name } = await deduplicateNewName(attachName + "." + path.extname(link), attachPathFile);
        debugLog("rearrangeAttachment - deduplicated name:", name);
        const dest = path.join(attachPath, name);
        await this.app.fileManager.renameFile(linkFile, dest);
      }
    }
  }
  /**
   * Retrieves the attachments in the specified vault of the given type.
   *
   * @param {AttachmentManagementPluginSettings} settings - the settings for the attachment management plugin
   * @param {"active" | "links"} type - the type of attachments to retrieve, either "active" or "links"
   * @return {Promise<Record<string, Set<string>>>} Returns a promise that resolves to a record containing sets of attachment names for each item ID in the specified vault.
   */
  async getAttachmentsInVault(settings, type) {
    let attachmentsRecord = {};
    attachmentsRecord = await this.getAttachmentsInVaultByLinks(settings, type);
    return attachmentsRecord;
  }
  /**
   * Modified from https://github.com/ozntel/oz-clear-unused-images-obsidian/blob/master/src/util.ts#LL48C21-L48C21
   * Retrieves a record of attachments in the vault based on the given settings and type.
   *
   * @param {AttachmentManagementPluginSettings} settings - The settings object used to filter attachments.
   * @param {"active" | "links"} type - The type of attachments to retrieve. Can be "active" or "links".
   * @return {Promise<Record<string, Set<string>>>} A record of attachments where the keys are the file paths and the values are sets of attachment paths.
   */
  async getAttachmentsInVaultByLinks(settings, type) {
    const attachmentsRecord = {};
    let resolvedLinks = {};
    let allFiles = [];
    if (type === "links") {
      resolvedLinks = this.app.metadataCache.resolvedLinks;
      allFiles = this.app.vault.getFiles();
    } else if (type === "active") {
      const file = getActiveFile(this.app);
      if (file) {
        if (file.parent && isExcluded(file.parent.path, this.settings) || isAttachment(this.settings, file)) {
          allFiles = [];
          new import_obsidian7.Notice(`${file.path} was excluded, skipped`);
        } else {
          debugLog("getAttachmentsInVaultByLinks - active file:", file.path);
          allFiles = [file];
          if (this.app.metadataCache.resolvedLinks[file.path]) {
            resolvedLinks[file.path] = this.app.metadataCache.resolvedLinks[file.path];
          }
          debugLog("getAttachmentsInVaultByLinks - resolvedLinks:", resolvedLinks);
        }
      }
    }
    debugLog("getAttachmentsInVaultByLinks - allFiles:", allFiles.length, allFiles);
    if (resolvedLinks) {
      for (const [mdFile, links] of Object.entries(resolvedLinks)) {
        const attachmentsSet = /* @__PURE__ */ new Set();
        for (const [filePath] of Object.entries(links)) {
          if (isAttachment(settings, filePath)) {
            this.addToSet(attachmentsSet, filePath);
          }
        }
        this.addToRecord(attachmentsRecord, mdFile, attachmentsSet);
      }
    }
    for (let i = 0; i < allFiles.length; i++) {
      const obsFile = allFiles[i];
      const attachmentsSet = /* @__PURE__ */ new Set();
      if (obsFile.parent && isExcluded(obsFile.parent.path, this.settings)) {
        continue;
      }
      if (isMarkdownFile(obsFile.extension)) {
        const fileCache = this.app.metadataCache.getFileCache(obsFile);
        if (fileCache === null) {
          continue;
        }
        if (fileCache.frontmatter) {
          const frontmatter = fileCache.frontmatter;
          for (const k of Object.keys(frontmatter)) {
            if (typeof frontmatter[k] === "string") {
              const formatMatch = frontmatter[k].match(bannerRegex);
              if (formatMatch && formatMatch[1]) {
                const fileName = formatMatch[1];
                const file = this.app.metadataCache.getFirstLinkpathDest(fileName, obsFile.path);
                if (file && isAttachment(settings, file.path)) {
                  this.addToSet(attachmentsSet, file.path);
                }
              }
            }
          }
        }
        const linkMatches = await getAllLinkMatchesInFile(obsFile, app);
        for (const linkMatch of linkMatches) {
          if (isAttachment(settings, linkMatch.linkText)) {
            this.addToSet(attachmentsSet, linkMatch.linkText);
          }
        }
      } else if (isCanvasFile(obsFile.extension)) {
        const fileRead = await this.app.vault.cachedRead(obsFile);
        if (!fileRead || fileRead.length === 0) {
          continue;
        }
        let canvasData;
        try {
          canvasData = JSON.parse(fileRead);
        } catch (e) {
          debugLog("getAttachmentsInVaultByLinks - parse canvas data error", e);
          continue;
        }
        if (canvasData.nodes && canvasData.nodes.length > 0) {
          for (const node of canvasData.nodes) {
            if (node.type === "file") {
              if (isAttachment(settings, node.file)) {
                this.addToSet(attachmentsSet, node.file);
              }
            } else if (node.type == "text") {
              const linkMatches = await getAllLinkMatchesInFile(obsFile, app, node.text);
              for (const linkMatch of linkMatches) {
                if (isAttachment(settings, linkMatch.linkText)) {
                  this.addToSet(attachmentsSet, linkMatch.linkText);
                }
              }
            }
          }
        }
      }
      this.addToRecord(attachmentsRecord, obsFile.path, attachmentsSet);
    }
    return attachmentsRecord;
  }
  addToRecord(record, key, value) {
    if (record[key] === void 0) {
      record[key] = value;
      return;
    }
    const valueSet = record[key];
    for (const val of value) {
      this.addToSet(valueSet, val);
    }
    record[key] = valueSet;
  }
  addToSet(setObj, value) {
    if (!setObj.has(value)) {
      setObj.add(value);
    }
  }
  needToRename(settings, attachPath, attachName, noteName, link) {
    const linkPath = path.dirname(link);
    const linkName = path.basename(link, path.extname(link));
    if (linkName.length !== attachName.length) {
      return true;
    }
    if (attachPath !== linkPath) {
      return true;
    } else {
      if (settings.attachFormat.includes(SETTINGS_VARIABLES_NOTENAME) && !linkName.includes(noteName)) {
        return true;
      }
      const noNoteNameAttachFormat = settings.attachFormat.split(SETTINGS_VARIABLES_NOTENAME);
      if (settings.attachFormat.includes(SETTINGS_VARIABLES_DATES)) {
        for (const formatPart in noNoteNameAttachFormat) {
          const splited = formatPart.split(SETTINGS_VARIABLES_DATES);
          for (const part in splited) {
            if (!linkName.includes(part)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
};

// src/create.ts
var import_obsidian8 = require("obsidian");
var CreateHandler = class {
  constructor(app2, settings) {
    this.app = app2;
    if (settings === void 0) {
      this.settings = DEFAULT_SETTINGS;
    } else {
      this.settings = settings;
    }
  }
  /**
   * Post-processing of created attachment file (for paste and drop event).
   * @param file - the file to process
   * @returns - none
   */
  async processAttach(file) {
    var _a;
    const activeFile = getActiveFile(this.app);
    if (activeFile === void 0) {
      new import_obsidian8.Notice("Error: no active file found.");
      return;
    }
    debugLog("processAttach - parent:", (_a = activeFile.parent) == null ? void 0 : _a.path);
    if (activeFile.parent && isExcluded(activeFile.parent.path, this.settings)) {
      debugLog("processAttach - not a file or exclude path:", activeFile.path);
      new import_obsidian8.Notice(`${activeFile.path} was excluded, skipped`);
      return;
    }
    const { setting } = getOverrideSetting(this.settings, activeFile);
    debugLog("processAttach - active file path", activeFile.path);
    const metadata = getMetadata(activeFile.path);
    debugLog("processAttach - metadata:", metadata);
    const attachPath = metadata.getAttachmentPath(setting);
    const attachName = metadata.getAttachFileName(setting, this.settings.dateFormat, file.basename) + "." + file.extension;
    if (!await this.app.vault.adapter.exists(attachPath, true)) {
      await this.app.vault.adapter.mkdir(attachPath);
      debugLog("processAttach - create path:", attachPath);
    }
    const attachPathFile = this.app.vault.getAbstractFileByPath(attachPath);
    const { name } = await deduplicateNewName(attachName, attachPathFile);
    debugLog("processAttach - new path of file:", path.join(attachPath, name));
    await this.renameCreateFile(file, attachPath, name, activeFile, true);
  }
  /**
   * Rename the file specified by `@param file`, and update the link of the file if specified updateLink
   * @param file - file to rename
   * @param attachPath - where to the renamed file will be move to
   * @param attachName - name of the renamed file
   * @param activeFile - associated active file
   * @param updateLink - whether to replace the link of renamed file
   * @returns - none
   */
  async renameCreateFile(file, attachPath, attachName, activeFile, updateLink) {
    const dst = (0, import_obsidian8.normalizePath)(path.join(attachPath, attachName));
    debugLog("renameFile - ", file.path, " to ", dst);
    const oldLinkText = this.app.fileManager.generateMarkdownLink(file, activeFile.path);
    const oldPath = file.path;
    const oldName = file.name;
    await this.app.vault.adapter.rename(file.path, dst);
    new import_obsidian8.Notice(`Renamed ${oldName} to ${attachName}.`);
    if (!updateLink) {
      return;
    }
    const newLinkText = this.app.fileManager.generateMarkdownLink(file, activeFile.path);
    debugLog("renameFile - replace text:", oldLinkText, newLinkText);
    const view = getActiveView(this.app);
    if (view === null) {
      new import_obsidian8.Notice(`Failed to update link in ${activeFile.path}: no active view`);
      return;
    }
    const content = view.getViewData();
    let val = "";
    switch (activeFile.extension) {
      case "md":
        val = content.replace(oldLinkText, newLinkText);
        break;
      case "canvas":
        val = content.replace(`/(files*:s*")${oldPath}(")/g`, `$1${dst}$2`);
        break;
    }
    view.setViewData(val, false);
    new import_obsidian8.Notice(`Updated 1 link in ${activeFile.path}`);
  }
};

// src/rename.ts
var import_obsidian9 = require("obsidian");
var RenameHandler = class {
  constructor(app2, settings) {
    this.app = app2;
    if (settings === void 0) {
      this.settings = DEFAULT_SETTINGS;
    } else {
      this.settings = settings;
    }
  }
  async onRename(file, oldPath, eventType, attachRenameType2 = "NULL" /* NULL */, setting) {
    const rf = file;
    const oldMetadata = getMetadata(oldPath);
    const newMetadata = getMetadata(file.path);
    debugLog("onRename - old metadata:", oldMetadata);
    debugLog("onRename - new metadata:", newMetadata);
    const oldAttachPath = oldMetadata.getAttachmentPath(setting);
    const newAttachPath = newMetadata.getAttachmentPath(setting);
    debugLog("onRename - old attachment path:", oldAttachPath);
    debugLog("onRename - new attachment path:", newAttachPath);
    if (!await this.app.vault.adapter.exists(oldAttachPath, true)) {
      debugLog("onRename - attachment path does not exist:", oldAttachPath);
      return;
    }
    if (!await this.app.vault.adapter.exists(newAttachPath, true)) {
      debugLog("onRename - mkdir:", newAttachPath);
      await this.app.vault.adapter.mkdir(newAttachPath);
    }
    let oldName = "";
    let newName = "";
    if (eventType === RENAME_EVENT_TYPE_FILE && (attachRenameType2 === "FILE" /* FILE */ || attachRenameType2 === "BOTH" /* BOTH */)) {
      oldName = oldMetadata.basename;
      newName = rf.basename;
    }
    await this.renameFolder(oldAttachPath, newAttachPath, attachRenameType2);
    if (eventType === RENAME_EVENT_TYPE_FILE && (attachRenameType2 === "FILE" /* FILE */ || attachRenameType2 === "BOTH" /* BOTH */)) {
      await this.renameFiles(oldAttachPath, newAttachPath, false, oldName, newName);
    }
  }
  /**
   * Renames attachment folder in the app's vault, this function only move the attachment files from
   * one place to another, not rename the filename.
   * @param {string} oldAttachPath - the original path of the folder
   * @param {string} newAttachPath - the new path of the folder
   * @param {ATTACHMENT_RENAME_TYPE} attachRenameType - the type of the attachment rename
   */
  async renameFolder(oldAttachPath, newAttachPath, attachRenameType2) {
    const { stripedSrc, stripedDst } = stripPaths(oldAttachPath, newAttachPath);
    debugLog("renameFolder - striped source:", stripedSrc);
    debugLog("renameFolder - striped destination:", stripedDst);
    if (stripedSrc === stripedDst) {
      debugLog("renameFolder - same striped path");
      return;
    }
    if (attachRenameType2 === "FOLDER" /* FOLDER */ || attachRenameType2 === "BOTH" /* BOTH */) {
      const exitsDst = await this.app.vault.adapter.exists(stripedDst, true);
      if (exitsDst) {
        debugLog("renameFolder - target folder exists:", stripedDst);
        await this.renameFiles(oldAttachPath, newAttachPath, true, "", "");
        const old = await this.app.vault.adapter.list(oldAttachPath);
        if (old.files.length === 0 && old.folders.length === 0) {
          await this.app.vault.adapter.rmdir(oldAttachPath, true);
        }
        return;
      } else {
        const src = this.app.vault.getAbstractFileByPath(stripedSrc);
        if (src === null) {
          debugLog("renameFolder - source file not exists:", stripedSrc);
          return;
        }
        debugLog("renameFolder - :", src.path, stripedDst);
        await this.app.fileManager.renameFile(src, stripedDst);
      }
    }
  }
  /**
   * Renames (or move) attachment files in the dstPath (or srcPath) directories. If the exists is true, it will
   * move the file from @param srcPath to @param dstPath.
   * @param {string} srcPath - The source directory path.
   * @param {string} dstPath - The destination directory path.
   * @param {boolean} exists - Determines whether to rename (or move) files.
   * @param {string} oldName - The old name of the notes, should be "" if the ${notename} was not used.
   * @param {string} newName - The new name of the notes, should be "" if the ${notename} was not used.
   */
  async renameFiles(srcPath, dstPath, exists, oldName, newName) {
    let attachmentFiles;
    if (exists) {
      attachmentFiles = await this.app.vault.adapter.list(srcPath);
    } else {
      attachmentFiles = await this.app.vault.adapter.list(dstPath);
    }
    debugLog("renameFiles - attachmentFiles:", attachmentFiles);
    for (const filePath of attachmentFiles.files) {
      let fileName = path.basename(filePath);
      const fileExtension = path.extname(fileName);
      if (this.settings.handleAll && testExcludeExtension(fileExtension, this.settings.excludeExtensionPattern) || !this.settings.handleAll && !isImage(fileExtension)) {
        debugLog("renameFiles - no handle extension:", fileExtension);
        continue;
      }
      fileName = fileName.replace(oldName, newName);
      debugLog("renameFiles - fileName:", fileName);
      if (filePath === (0, import_obsidian9.normalizePath)(path.join(dstPath, fileName))) {
        debugLog("renameFiles - same src and dst:", filePath);
        continue;
      }
      const dstFolder = this.app.vault.getAbstractFileByPath(dstPath), { name } = await deduplicateNewName(fileName, dstFolder), newFilePath = (0, import_obsidian9.normalizePath)(path.join(dstPath, name)), src = this.app.vault.getAbstractFileByPath(filePath);
      debugLog("renameFiles - new file path:", newFilePath);
      if (src === null) {
        continue;
      }
      await this.app.fileManager.renameFile(src, newFilePath);
    }
  }
};

// src/main.ts
var AttachmentManagementPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    console.log(`Plugin loading: ${this.manifest.name} v.${this.manifest.version}`);
    this.addCommand({
      id: "attachment-management-rearrange-all-links",
      name: "Rearrange all linked attachments",
      callback: () => {
        new ArrangeHandler(this.settings, this.app).rearrangeAttachment("links");
        new import_obsidian10.Notice("Arrange completed");
      }
    });
    this.addCommand({
      id: "attachment-management-rearrange-active-links",
      name: "Rearrange linked attachments",
      callback: () => {
        new ArrangeHandler(this.settings, this.app).rearrangeAttachment("active");
        new import_obsidian10.Notice("Arrange completed");
      }
    });
    this.addCommand({
      id: "override-setting",
      name: "Overriding setting",
      checkCallback: (checking) => {
        const file = getActiveFile(this.app);
        if (file) {
          if (isAttachment(this.settings, file)) {
            new import_obsidian10.Notice(`${file.path} is an attachment, skipped`);
            return true;
          }
          if (!checking) {
            if (file.parent && isExcluded(file.parent.path, this.settings)) {
              new import_obsidian10.Notice(`${file.path} was excluded, skipped`);
              return true;
            }
            const { setting } = getOverrideSetting(this.settings, file);
            const fileSetting = Object.assign({}, setting);
            this.overrideConfiguration(file, fileSetting);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "reset-override-setting",
      name: "Reset override setting",
      checkCallback: (checking) => {
        const file = getActiveFile(this.app);
        if (file) {
          if (isAttachment(this.settings, file)) {
            new import_obsidian10.Notice(`${file.path} is an attachment, skipped`);
            return true;
          }
          if (!checking) {
            if (file.parent && isExcluded(file.parent.path, this.settings)) {
              new import_obsidian10.Notice(`${file.path} was excluded, skipped`);
              return true;
            }
            delete this.settings.overridePath[file.path];
            this.saveSettings();
            new import_obsidian10.Notice(`Reset attachment setting of ${file.path}`);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", async (menu, file) => {
        if (file.parent && isExcluded(file.parent.path, this.settings) || isAttachment(this.settings, file)) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Overriding attachment setting").setIcon("image-plus").onClick(async () => {
            const { setting } = getOverrideSetting(this.settings, file);
            const fileSetting = Object.assign({}, setting);
            await this.overrideConfiguration(file, fileSetting);
          });
        });
      })
    );
    this.registerEvent(
      // not working while drop file to text view
      this.app.vault.on("create", async (file) => {
        debugLog("on create event - file:", file.path);
        if (!(file instanceof import_obsidian10.TFile)) {
          return;
        }
        this.app.workspace.onLayoutReady(async () => {
          const timeGapMs = new Date().getTime() - file.stat.mtime;
          if (timeGapMs > 1e3) {
            return;
          }
          if (isMarkdownFile(file.extension) || isCanvasFile(file.extension)) {
            return;
          }
          const processor = new CreateHandler(this.app, this.settings);
          if (isImage(file.extension) || isPastedImage(file)) {
            debugLog("create - image", file);
            await processor.processAttach(file);
          } else {
            if (this.settings.handleAll) {
              debugLog("create - handleAll for file", file);
              if (testExcludeExtension(file.extension, this.settings.excludeExtensionPattern)) {
                debugLog("create - excluded file by extension", file);
                return;
              }
              await processor.processAttach(file);
            }
          }
        });
      })
    );
    this.registerEvent(
      // while trigger rename event on rename a folder, for each file/folder in this renamed folder (include itself) will trigger this event
      this.app.vault.on("rename", async (file, oldPath) => {
        debugLog("on rename event - new path and old path:", file.path, oldPath);
        const { setting } = getRenameOverrideSetting(this.settings, file, oldPath);
        debugLog("rename - using settings:", setting);
        if (setting.type === "FOLDER" /* FOLDER */ || setting.type === "FILE" /* FILE */) {
          updateOverrideSetting(this.settings, file, oldPath);
          await this.saveSettings();
          await this.loadSettings();
        }
        debugLog("rename - updated settings:", setting);
        if (!this.settings.autoRenameAttachment) {
          debugLog("rename - auto rename not enabled:", this.settings.autoRenameAttachment);
          return;
        }
        const type = attachRenameType(setting);
        debugLog("rename - attachRenameType:", type);
        if (type === "NULL" /* NULL */) {
          debugLog("rename - no variable use, skipped");
          return;
        }
        if (file instanceof import_obsidian10.TFile) {
          if (file.parent && isExcluded(file.parent.path, this.settings)) {
            debugLog("rename - exclude path:", file.parent.path);
            new import_obsidian10.Notice(`${file.path} was excluded, skipped`);
            return;
          }
          const flag = isAttachment(this.settings, file);
          if (flag) {
            debugLog("rename - not processing rename on attachment:", file.path);
            return;
          }
          let eventType;
          if (path.basename(oldPath, path.extname(oldPath)) === path.basename(file.path, path.extname(file.path))) {
            eventType = RENAME_EVENT_TYPE_FOLDER;
            debugLog("rename - RENAME_EVENT_TYPE:", RENAME_EVENT_TYPE_FOLDER);
          } else {
            eventType = RENAME_EVENT_TYPE_FILE;
            debugLog("rename - RENAME_EVENT_TYPE:", RENAME_EVENT_TYPE_FILE);
          }
          const processor = new RenameHandler(this.app, this.settings);
          await processor.onRename(file, oldPath, eventType, type, setting);
        } else if (file instanceof import_obsidian10.TFolder) {
          return;
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        debugLog("on delete event - file path:", file.path);
        if (file.parent && isExcluded(file.parent.path, this.settings) || isAttachment(this.settings, file)) {
          debugLog("rename - exclude path or the file is an attachment:", file.path);
          return;
        }
        if (deleteOverrideSetting(this.settings, file)) {
          new import_obsidian10.Notice("Removed override setting of " + file.path);
        }
      })
    );
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async overrideConfiguration(file, setting) {
    new OverrideModal(this, file, setting).open();
    await this.loadSettings();
  }
  backupConfigs() {
    this.originalObsAttachPath = this.app.vault.getConfig("attachmentFolderPath");
  }
  restoreConfigs() {
    this.app.vault.setConfig("attachmentFolderPath", this.originalObsAttachPath);
  }
  updateAttachmentFolderConfig(path2) {
    this.app.vault.setConfig("attachmentFolderPath", path2);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
